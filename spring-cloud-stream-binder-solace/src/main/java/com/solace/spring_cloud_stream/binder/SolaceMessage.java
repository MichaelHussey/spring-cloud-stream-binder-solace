/**
 * 
 */
package com.solace.spring_cloud_stream.binder;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

import org.springframework.messaging.Message;
import org.springframework.messaging.MessageHeaders;
import org.springframework.messaging.support.MessageBuilder;

import com.solacesystems.jcsmp.BytesXMLMessage;
import com.solacesystems.jcsmp.Destination;
import com.solacesystems.jcsmp.JCSMPFactory;
import com.solacesystems.jcsmp.MapMessage;
import com.solacesystems.jcsmp.Queue;
import com.solacesystems.jcsmp.SDTException;
import com.solacesystems.jcsmp.SDTMap;
import com.solacesystems.jcsmp.TextMessage;
import com.solacesystems.jcsmp.XMLMessage;

import ch.qos.logback.classic.Logger;

/**
 * Wrapper around a received Solace message which maps it to a Spring Message and vice versa
 * 
 * When sending from Spring to Solace the payload is mapped as follows:
 * 	| Spring payload type | Solace message type |
 *  ---------------------------------------------
 *  | String              | TextMessage         |
 *  | Map                 | MapMessage          | Key names are generated by calling toString()
 *  | Object              | BytesXMLMessage     | Serialized Java Object 
 *  Other types of payloads are not supported.
 *  
 * @author michussey
 * @param <T>
 *
 */
public class SolaceMessage<T> implements Message<T>, Serializable {

	/**
	 * 
	 */
	private static final long serialVersionUID = 8868969204325357275L;

	private XMLMessage solaceMessage;

	private MessageHeaders springHeaders;

	private Message<?> springMessage;

	private T payload;

	private enum MappingDirection {
		SOLACE2SPRING, SPRING2SOLACE
	}

	private MappingDirection direction;

	private String toDestinationName;

	/**
	 * Make the default constructor private.
	 */
	@SuppressWarnings("unused")
	private SolaceMessage() {	
	}

	/**
	 * This constructor does the mapping between a Solace wireformat and the Spring GenericMessage representation.
	 * @param originalMessage
	 * @throws SolaceBinderException 
	 */
	@SuppressWarnings("unchecked")
	public SolaceMessage(XMLMessage originalMessage) throws SolaceBinderException {
		this.solaceMessage = originalMessage;
		this.direction = MappingDirection.SOLACE2SPRING;

		// Map the headers
		HashMap<String, Object> headerMap = mapSolaceHeaders(originalMessage);
		this.springHeaders = new MessageHeaders(headerMap);
		// Map the content
		if (originalMessage instanceof TextMessage) {
			TextMessage tMessage = (TextMessage) originalMessage;
			payload = (T) tMessage.getText();
		} else if (originalMessage instanceof MapMessage) {
			SDTMap solaceMap = ((MapMessage) originalMessage).getMap();
			try {
				payload = (T) solaceMapToMap(solaceMap);
			} catch (SDTException e) {
				throw new SolaceBinderException("Error mapping Solace headers", e);
			}
		}
		this.springMessage = MessageBuilder.createMessage(payload, this.springHeaders);
	}
	protected HashMap<String, Object> solaceMapToMap(SDTMap solaceMap) throws SDTException
	{
		HashMap<String, Object> retMap = new HashMap<String, Object>();
		Iterator iter = solaceMap.keySet().iterator();
		while (iter.hasNext()) {
			String key = (String) iter.next();
			Object value = solaceMap.get(key);
			Object valueMapped = null;
			if (value instanceof SDTMap) {
				valueMapped = solaceMapToMap((SDTMap) value);
			}
			else
			{
				valueMapped = value;
			}
			retMap.put(key, valueMapped);	
		}
		return retMap;
	}

	/**
	 * 
	 * @param solaceWireMessage
	 * @return
	 */
	protected HashMap<String, Object> mapSolaceHeaders(XMLMessage solaceWireMessage) {
		HashMap<String, Object> headerMap = new HashMap<String, Object>();

		// TODO: set all the standard header properties

		headerMap = Utils.putIfNotNull(headerMap, SolaceBinderConstants.FIELD_APPLICATION_MESSAGE_ID, 
				solaceMessage.getApplicationMessageId());
		headerMap = Utils.putIfNotNull(headerMap, SolaceBinderConstants.FIELD_CORRELATION_ID, 
				solaceMessage.getCorrelationKey());
		headerMap = Utils.putIfNotNull(headerMap, SolaceBinderConstants.FIELD_APPLICATION_MESSAGE_TYPE, 
				solaceMessage.getApplicationMessageType());
		headerMap = Utils.putIfNotNull(headerMap, SolaceBinderConstants.FIELD_SENDERID, 
				solaceMessage.getSenderId());
		headerMap = Utils.putIfNotNull(headerMap, SolaceBinderConstants.FIELD_SENDER_TIMESTAMP, 
				solaceMessage.getSenderTimestamp());

		// Store the topic or queue name on which we received the message
		Destination dest = solaceMessage.getDestination();
		if (dest != null) {
			String prefix = "T/";
			if (dest instanceof Queue) {
				prefix = "Q/";
			}
			headerMap.put(SolaceBinderConstants.FIELD_DESTINATION_NAME, prefix+dest.getName());
		}

		Destination reply_dest = solaceMessage.getReplyTo();
		if (reply_dest != null) {
			String prefix = "T/";
			if (reply_dest instanceof Queue) {
				prefix = "Q/";
			}
			headerMap.put(SolaceBinderConstants.FIELD_REPLYDESTINATION_NAME, prefix+reply_dest.getName());
		}

		// Map any user properties
		SDTMap userProperties = solaceMessage.getProperties();
		if (userProperties != null)
		{
			Iterator<String> iter = userProperties.keySet().iterator();
			while (iter.hasNext())
			{
				String key = iter.next();
				try {
					headerMap.put(key, userProperties.get(key));
				} catch (SDTException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
		}
		return headerMap;
	}

	/**
	 * 
	 * @param springMessage
	 */
	@SuppressWarnings("unchecked")
	public SolaceMessage(Message<?> springMessage) {
		this.springMessage = springMessage;
		this.direction = MappingDirection.SPRING2SOLACE;
		this.springHeaders = springMessage.getHeaders();
		this.payload = (T) springMessage.getPayload();
	}

	/**
	 * Generates a Solace representation of the Spring message
	 *
	 * @return true if the destination needs to be changed.
	 * @throws SolaceBinderException
	 */
	public boolean toSolace() throws SolaceBinderException
	{
		boolean retVal = false;

		if (springHeaders.containsKey(SolaceBinderConstants.FIELD_CORRELATION_ID)) {
			solaceMessage.setCorrelationId((String) springHeaders.get(SolaceBinderConstants.FIELD_CORRELATION_ID));
		}
		Object payloadObject = springMessage.getPayload();
		if (payloadObject instanceof byte[])
		{
			solaceMessage = JCSMPFactory.onlyInstance().createMessage(BytesXMLMessage.class);
			byte[] payloadBytes = (byte[]) payloadObject;
			solaceMessage.writeAttachment(payloadBytes);
		}
		else if (payloadObject instanceof String) {
			solaceMessage = JCSMPFactory.onlyInstance().createMessage(TextMessage.class);
			((TextMessage) solaceMessage).setText((String)payloadObject);
		}
		else if (payloadObject instanceof Map) {
			solaceMessage  = JCSMPFactory.onlyInstance().createMessage(MapMessage.class);
			SDTMap solaceMap = JCSMPFactory.onlyInstance().createMap();
			Map<Object, Object> mapObject = (Map<Object, Object>) payloadObject;
			Iterator<Object> iter = mapObject.keySet().iterator();
			while (iter.hasNext())
			{
				Object key = iter.next();
				Object value = mapObject.get(key);
				try {
					solaceMap.putObject(key.toString(), value);
				} catch (SDTException e) {
					throw new SolaceBinderException("Error adding key ["+key+"] with value ["+value+"] to Solace Map payload", e);
				}
			}
			((MapMessage) solaceMessage).setMap(solaceMap);
		}
		else if (Serializable.class.isInstance(payloadObject) && payloadObject != null)
		{
			solaceMessage = JCSMPFactory.onlyInstance().createMessage(BytesXMLMessage.class);
			ByteArrayOutputStream baos = new ByteArrayOutputStream();
			ObjectOutputStream os;
			try {
				os = new ObjectOutputStream(baos);
				os.writeObject(payloadObject);
				os.close();
			} catch (IOException e) {
				throw new SolaceBinderException("Error serializing payload object ["+payloadObject+"] to a byte array", e);
			}
			byte[] payloadBytes = baos.toByteArray();
			int payloadSize = payloadBytes.length;
			((BytesXMLMessage) solaceMessage).writeBytes(payloadBytes);
		}
		else
		{
			throw new SolaceBinderException("Can't handle payload of type ["+payloadObject.getClass().getName()+"]");
		}

		// Handle dynamic destinations (eg replyTo cases)
		if (springHeaders.containsKey(SolaceBinderConstants.FIELD_DESTINATION)) {
			toDestinationName = (String) springHeaders.get(SolaceBinderConstants.FIELD_DESTINATION);
			retVal = true;
		}
		return retVal;
	}

	public Destination getSolaceDestination(SolaceProducerDestination producerDestn) throws SolaceBinderException
	{
		if (direction != MappingDirection.SPRING2SOLACE)
			throw new SolaceBinderException("This method is only valid when sending a Spring message to Solace");

		Destination sendDestination = producerDestn.getTopic();
		if (!producerDestn.getName().equals(toDestinationName))
		{
			sendDestination = JCSMPFactory.onlyInstance().createTopic(toDestinationName);
		}
		return sendDestination;
	}


	public XMLMessage getSolaceMessage() {
		return solaceMessage;
	}

	@Override
	public T getPayload() {
		if (payload == null) 
		{
			if (this.direction == MappingDirection.SOLACE2SPRING && solaceMessage != null) {
				// TODO: Extract the payload from the solaceMessage
		
			}
		}
		return payload;
	}

	@Override
	public MessageHeaders getHeaders() {
		return springHeaders;
	}

	public MappingDirection getDirection() {
		return direction;
	}	
}
