/**
 * 
 */
package com.solace.spring_cloud_stream.binder;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.io.UnsupportedEncodingException;
import java.nio.ByteBuffer;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.messaging.Message;
import org.springframework.messaging.MessageHeaders;
import org.springframework.messaging.support.MessageBuilder;

import com.solacesystems.jcsmp.BytesXMLMessage;
import com.solacesystems.jcsmp.Destination;
import com.solacesystems.jcsmp.JCSMPFactory;
import com.solacesystems.jcsmp.MapMessage;
import com.solacesystems.jcsmp.Queue;
import com.solacesystems.jcsmp.SDTException;
import com.solacesystems.jcsmp.SDTMap;
import com.solacesystems.jcsmp.TextMessage;
import com.solacesystems.jcsmp.XMLMessage;

/**
 * Wrapper around a received Solace message which maps it to a Spring Message and vice versa
 * 
 * When sending from Spring to Solace the payload is mapped as follows:
 * 	| Spring payload type | Solace message type |
 *  ---------------------------------------------
 *  | String              | TextMessage         |
 *  | Map                 | MapMessage          | Key names are generated by calling toString()
 *  | Object              | BytesXMLMessage     | Serialized Java Object 
 *  Other types of payloads are not supported.
 *  
 * @author michussey
 * @param <T>
 *
 */
public class SolaceMessage<T> implements Message<T>, Serializable {

	private static final Logger logger = LoggerFactory.getLogger(SolaceMessage.class);
	/**
	 * 
	 */
	private static final long serialVersionUID = 8868969204325357275L;

	private XMLMessage solaceMessage;

	private MessageHeaders springHeaders;

	private Message<?> springMessage;

	private T payload;

	private enum MappingDirection {
		SOLACE2SPRING, SPRING2SOLACE
	}

	private MappingDirection direction;

	private String toDestinationName;

	/**
	 * Make the default constructor private.
	 */
	@SuppressWarnings("unused")
	private SolaceMessage() {	
	}

	/**
	 * This constructor does the mapping between a Solace wireformat and the Spring GenericMessage representation.
	 * @param originalMessage
	 * @throws SolaceBinderException 
	 */
	@SuppressWarnings("unchecked")
	public SolaceMessage(XMLMessage originalMessage) throws SolaceBinderException {
		this.solaceMessage = originalMessage;
		this.direction = MappingDirection.SOLACE2SPRING;

		// Map the headers
		HashMap<String, Object> headerMap = mapSolaceHeaders(originalMessage);
		this.springHeaders = new MessageHeaders(headerMap);
		// Map the content
		if (originalMessage instanceof TextMessage) {
			TextMessage tMessage = (TextMessage) originalMessage;
			if (tMessage.getContentLength() > 0) {
				payload = (T) tMessage.getText();
			} else if (tMessage.getAttachmentContentLength() > 0) {
				// TODO read character-encodig from a message header or provide via configuration
				String contentType = tMessage.getHTTPContentType();
				logger.info("TextMessage, content-type: "+contentType);
				String charSet = "UTF-8";
				try {
					ByteBuffer aBB = tMessage.getAttachmentByteBuffer();
					if (aBB.hasArray()) {
						payload = (T) new String(aBB.array(),
								2,
								tMessage.getAttachmentContentLength()-3, charSet);
					} else {
						final byte[] b = new byte[aBB.remaining()];
						aBB.duplicate().get(b);
						payload = (T) new String(b, charSet);
					}
				} catch (UnsupportedEncodingException e) {
					throw new SolaceBinderException("Error creating String payload from message attachment", e);
				}
			} else {
				// null payload
				payload = null;
			}
		} else if (originalMessage instanceof MapMessage) {
			SDTMap solaceMap = ((MapMessage) originalMessage).getMap();
			try {
				payload = (T) solaceMapToMap(solaceMap);
			} catch (SDTException e) {
				throw new SolaceBinderException("Error mapping Solace headers", e);
			}
		}
		this.springMessage = MessageBuilder.createMessage(payload, this.springHeaders);
	}
	protected HashMap<String, Object> solaceMapToMap(SDTMap solaceMap) throws SDTException
	{
		HashMap<String, Object> retMap = new HashMap<String, Object>();
		Iterator iter = solaceMap.keySet().iterator();
		while (iter.hasNext()) {
			String key = (String) iter.next();
			Object value = solaceMap.get(key);
			Object valueMapped = null;
			if (value instanceof SDTMap) {
				valueMapped = solaceMapToMap((SDTMap) value);
			}
			else
			{
				valueMapped = value;
			}
			retMap.put(key, valueMapped);	
		}
		return retMap;
	}

	/**
	 * 
	 * @param solaceWireMessage
	 * @return
	 */
	protected HashMap<String, Object> mapSolaceHeaders(XMLMessage solaceWireMessage) {
		HashMap<String, Object> headerMap = new HashMap<String, Object>();

		if (solaceWireMessage != null) {
			// TODO: set all the standard header properties

			headerMap = Utils.putIfNotNull(headerMap, SolaceBinderConstants.FIELD_APPLICATION_MESSAGE_ID, 
					solaceMessage.getApplicationMessageId());
			headerMap = Utils.putIfNotNull(headerMap, SolaceBinderConstants.FIELD_CORRELATION_ID, 
					solaceMessage.getCorrelationKey());
			headerMap = Utils.putIfNotNull(headerMap, SolaceBinderConstants.FIELD_APPLICATION_MESSAGE_TYPE, 
					solaceMessage.getApplicationMessageType());
			headerMap = Utils.putIfNotNull(headerMap, SolaceBinderConstants.FIELD_SENDERID, 
					solaceMessage.getSenderId());
			headerMap = Utils.putIfNotNull(headerMap, SolaceBinderConstants.FIELD_SENDER_TIMESTAMP, 
					solaceMessage.getSenderTimestamp());

			// Store the topic or queue name on which we received the message
			Destination dest = solaceMessage.getDestination();
			if (dest != null) {
				if (dest instanceof Queue) {
					headerMap.put(SolaceBinderConstants.FIELD_DESTINATION_TYPE, SolaceBinderConstants.DESTINATION_TYPE.QUEUE);
				} else {
					headerMap.put(SolaceBinderConstants.FIELD_DESTINATION_TYPE, SolaceBinderConstants.DESTINATION_TYPE.TOPIC);				
				}
				headerMap.put(SolaceBinderConstants.FIELD_DESTINATION_NAME, dest.getName());
			}

			Destination reply_dest = solaceMessage.getReplyTo();
			if (reply_dest != null) {
				if (reply_dest instanceof Queue) {
					headerMap.put(SolaceBinderConstants.FIELD_REPLYDESTINATION_TYPE, SolaceBinderConstants.DESTINATION_TYPE.QUEUE);
				}
				else
				{
					headerMap.put(SolaceBinderConstants.FIELD_REPLYDESTINATION_TYPE, SolaceBinderConstants.DESTINATION_TYPE.TOPIC);
				}
				headerMap.put(SolaceBinderConstants.FIELD_REPLYDESTINATION_NAME, reply_dest.getName());
			}

			// Map any user properties
			SDTMap userProperties = solaceMessage.getProperties();
			if (userProperties != null)
			{
				Iterator<String> iter = userProperties.keySet().iterator();
				while (iter.hasNext())
				{
					String key = iter.next();
					try {
						headerMap.put(key, userProperties.get(key));
					} catch (SDTException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
			}

		}
		return headerMap;
	}

	/**
	 * 
	 * @param springMessage
	 */
	@SuppressWarnings("unchecked")
	public SolaceMessage(Message<?> springMessage) {
		this.springMessage = springMessage;
		this.direction = MappingDirection.SPRING2SOLACE;
		this.springHeaders = springMessage.getHeaders();
		this.payload = (T) springMessage.getPayload();
	}
	/**
	 * 
	 * @param springMessage
	 */
	@SuppressWarnings("unchecked")
	public SolaceMessage(Object payload, MessageHeaders headers) {
		this.direction = MappingDirection.SPRING2SOLACE;
		this.springHeaders = headers;
		this.payload = (T) payload;
	}

	/**
	 * Generates a Solace representation of the Spring message
	 *
	 * @return true if the destination needs to be changed.
	 * @throws SolaceBinderException
	 */
	public boolean toSolace() throws SolaceBinderException
	{
		boolean retVal = false;

		Object payloadObject = springMessage.getPayload();
		if (payloadObject instanceof byte[])
		{
			solaceMessage = JCSMPFactory.onlyInstance().createMessage(BytesXMLMessage.class);
			byte[] payloadBytes = (byte[]) payloadObject;
			solaceMessage.writeAttachment(payloadBytes);
		}
		else if (payloadObject instanceof String) {
			solaceMessage = JCSMPFactory.onlyInstance().createMessage(TextMessage.class);
			((TextMessage) solaceMessage).setText((String)payloadObject);
		}
		else if (payloadObject instanceof Map) {
			solaceMessage  = JCSMPFactory.onlyInstance().createMessage(MapMessage.class);
			SDTMap solaceMap = JCSMPFactory.onlyInstance().createMap();
			Map<Object, Object> mapObject = (Map<Object, Object>) payloadObject;
			Iterator<Object> iter = mapObject.keySet().iterator();
			while (iter.hasNext())
			{
				Object key = iter.next();
				Object value = mapObject.get(key);
				try {
					solaceMap.putObject(key.toString(), value);
				} catch (SDTException e) {
					throw new SolaceBinderException("Error adding key ["+key+"] with value ["+value+"] to Solace Map payload", e);
				}
			}
			((MapMessage) solaceMessage).setMap(solaceMap);
		}
		else if (Serializable.class.isInstance(payloadObject) && payloadObject != null)
		{
			solaceMessage = JCSMPFactory.onlyInstance().createMessage(BytesXMLMessage.class);
			ByteArrayOutputStream baos = new ByteArrayOutputStream();
			ObjectOutputStream os;
			try {
				os = new ObjectOutputStream(baos);
				os.writeObject(payloadObject);
				os.close();
			} catch (IOException e) {
				throw new SolaceBinderException("Error serializing payload object ["+payloadObject+"] to a byte array", e);
			}
			byte[] payloadBytes = baos.toByteArray();
			int payloadSize = payloadBytes.length;
			((BytesXMLMessage) solaceMessage).writeBytes(payloadBytes);
		}
		else
		{
			throw new SolaceBinderException("Can't handle payload of type ["+payloadObject.getClass().getName()+"]");
		}

		// TODO - map other relevant outbound headers...
		if (springHeaders.containsKey(SolaceBinderConstants.FIELD_CORRELATION_ID)) {
			solaceMessage.setCorrelationId((String) springHeaders.get(SolaceBinderConstants.FIELD_CORRELATION_ID));
		}

		// Handle dynamic destinations (eg replyTo cases)
		if (springHeaders.containsKey(SolaceBinderConstants.FIELD_DYNAMICDESTINATION_NAME)) {
			toDestinationName = (String) springHeaders.get(SolaceBinderConstants.FIELD_DYNAMICDESTINATION_NAME);
			retVal = true;
		}
		return retVal;
	}

	public Destination getSolaceDestination(SolaceProducerDestination producerDestn) throws SolaceBinderException
	{
		if (direction != MappingDirection.SPRING2SOLACE)
			throw new SolaceBinderException("This method is only valid when sending a Spring message to Solace");

		Destination sendDestination = producerDestn.getTopic();
		if (!producerDestn.getName().equals(toDestinationName))
		{
			sendDestination = JCSMPFactory.onlyInstance().createTopic(toDestinationName);
		}
		return sendDestination;
	}


	public XMLMessage getSolaceMessage() {
		return solaceMessage;
	}

	@Override
	public T getPayload() {
		if (payload == null) 
		{
			if (this.direction == MappingDirection.SOLACE2SPRING && solaceMessage != null) {
				// TODO: Extract the payload from the solaceMessage

			}
		}
		return payload;
	}

	@Override
	public MessageHeaders getHeaders() {
		return springHeaders;
	}

	public MappingDirection getDirection() {
		return direction;
	}	

	public String toString() {
		StringBuilder sb = new StringBuilder(getClass().getSimpleName());
		sb.append(" [payload=");
		if (this.payload instanceof byte[]) {
			sb.append("byte[").append(((byte[]) this.payload).length).append("]");
		}
		else {
			sb.append(this.payload);
		}
		sb.append(", springHeaders=").append(this.springHeaders);
		sb.append(", solaceHeaders=").append(mapSolaceHeaders(this.solaceMessage));
		sb.append("]");
		return sb.toString();

	}
}
